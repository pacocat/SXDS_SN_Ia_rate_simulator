#!/opt/local/bin/python"""# Written by Jun E. Okumura in 2014.02# contact paco.sci@gmail.com if you have any questions or comments.This code generates light curves from published spectrum templates.Supported templates are:- SN Ia by Eric Hsiao- SN Ia by Peter Nugent- 91bg-like SN Ia by Peter Nugent- 91T-like SN Ia by Peter Nugent- SN Ibc by Peter Nugent- SN IIL by Peter Nugent- SN IIP by Peter Nugent- SN IIn by Peter NugentSupported fileters are:- Subaru/Suprime-Cam (SC)- Subaru/Hyper Suprime-Cam (HSC)These opetions are defined in variable 'camera_type' and 'object_type'.(See below this manuscript)## NOTE ##To run this code, those packages below is required.If you don't have them, try to download those packages first.1. numpy (the author used version '1.8.0'; see http://www.numpy.org/)2. scipy (the author used version '0.12.0'; see http://www.scipy.org/)3. pyfist (the author used version '3.1.1'; see http://www.stsci.edu/institute/software_hardware/pyfits)4. cosmolopy or astropy (this code support both cases)- cosmolopy (see http://roban.github.io/CosmoloPy/)- astropy (see http://www.astropy.org/)"""### options ###camera_type = 0# [0:SC 1:HSC]object_type = 4# 0:SN Ia (Hsiao) 1:SN Ia (Nugent) 2:SN Ia-91bg (Nugent) 3:SN Ia-91T (Nugent)# 4:SN Ibc (Nugent) 5:SN IIL (Nugent) 6:SN IIP (Nugent) 7:SN IIn (Nugent)absmag_type = 'B'absmag_norm = -18.0# magnitude normalization# if you put absmag_type = 'B' and absmag_norm = -19.0, # the output LC is noramalised so that M_B in Johnson filter to be -19.0 mag at maximum# load modules from numpy, scipy, pyfitsimport numpy as npimport scipy.interpolateimport pyfitsimport time# load cosmology calculator package# First, try to import cosmolopy. If cosmolopy is not installed, # try to import astopy instead. The package name is labeled in# the variable cosmology_package_flag [1: cosmolopy 2:astropy]cosmology_package_flag = 0try:    print 'loading astronomical tool [cosmolopy]...'    from cosmolopy.distance import  comoving_distance    from cosmolopy.magnitudes import distance_modulus    cosmo = {'omega_M_0':0.3, 'omega_lambda_0':0.7, 'omega_k_0':0.0, 'h':0.70}    cosmology_package_flag = 1    print 'successfully loaded cosmolpy!'    """    # usage    > comoving_distance=cosmocd.comoving_distance(1.0, **cosmo)    > comoving_distance     array(3303.8288058874678) # Mpc    > distance_modulus=5.*np.log10(comoving_distance)+5.*np.log10(1.+1.0)+25.    > distance_modulus     44.100237655543722 # mag    or    > distance_modulus(1.0, **cosmo)     44.100237655543722 # mag    """except Exception as e:    print e.message # print error message    print 'loading astronomical tool [astropy]...'    from astropy.cosmology import FlatLambdaCDM    import astropy.units as u    cosmo = FlatLambdaCDM(H0=70 * u.km / u.s / u.Mpc, Om0=0.3)    cosmology_package_flag = 2    print 'successfully loaded astopy!'    """    # usage    > cosmo.comoving_distance(1.0).value     3303.5264530419586 # Mpc    > cosmo.distmod(1.0).value     44.100038922211944 # mag    """# define constantsc = 2.989e10 # speed of the light in [cm s-1] unitab_0 = -48.6 # used in the AB magnitude alculation def abmagnitude(model_nu15,model_fnu,filter_nu15,filter_responce,z):    """    A function to calculate AB magnitude.    This function revieve model SED, filter information and redshift.    The output is the magnitude of the object at certain redshift.    The integration method is "Quadrature by Parts"    """    # interpolate model SED    flux=scipy.interpolate.interp1d(model_nu15,model_fnu,kind="linear")    # start of integration    numerator=0.0    denominator=0.0    for i in range(len(filter_nu15)-1):        for j in range(len(model_fnu)):            if (filter_nu15[i]*(1.+z) <= model_nu15[j]) and (filter_nu15[i]*(1.+z) >= model_nu15[j-1]):                dnu=(filter_nu15[i+1]-filter_nu15[i])                numerator+=flux(filter_nu15[i]*(1.+z))/filter_nu15[i]*filter_responce[i]*dnu                denominator+=1.0/filter_nu15[i]*filter_responce[i]*dnu    mag=-2.5*np.log10(numerator/denominator)+ab_0-2.5*np.log10(1.+z)    return magdef convert_nu(filter):    """    This function is used to convert wavelength (lambda) to frequency (nu).    """    filter_lam=filter[:,0]*1.0e-8 # [cm]    filter_nu=np.array([0.0] * len(filter_lam))    for i in range(len(filter_lam)):        filter_nu[i]=c/filter_lam[len(filter_lam)-1-i] # [Hz]    return filter_nu*1.0e-15def convert_fnu(filter):    """    This function is used to convert the unit of filter responce to frenquency (nu).    """    filter_lam=filter[:,0]*1.0e-8 # [cm]    filter_responce=np.array([0.0] * len(filter_lam))    for i in range(len(filter_lam)):        filter_responce[i]=filter[len(filter_lam)-1-i,1]    return filter_responcedef AB_Vega_calc(filter):    """    This is a Vega -> AB conversion function.    """    # load Vega flux (based on the HST observation from Bohlin 2001)    fitsfile='./Vega_spectrum/alpha_lyr_stis_003.fits'    hdulist=pyfits.open(fitsfile)    tbdata=hdulist[1].data    vegawavelength=tbdata.field('WAVELENGTH')    vegaflux=tbdata.field('FLUX')    staterr=tbdata.field('STATERROR')    systerr=tbdata.field('SYSERROR')    # set up filter response    res=scipy.interpolate.interp1d(filter[:,0],filter[:,1],kind="linear")    vegaflux_jy=vegaflux*vegawavelength*vegawavelength*1.e5/3.0 # in Jy unit    # start of intergration    numerator = 0.0    denominator = 0.0    for i in range(len(vegawavelength)):        if (vegawavelength[i] >= min(filter[:,0])) and (vegawavelength[i] <= max(filter[:,0]) ):            if(i==0):                dlambda=vegawavelength[1] - vegawavelength[0]            else:                dlambda=vegawavelength[i] - vegawavelength[i-1]            numerator+=vegawavelength[i]*res(vegawavelength[i])*vegaflux[i]*dlambda            denominator+=res(vegawavelength[i])/vegawavelength[i]*dlambda    AB_Vega=-2.5*np.log10(numerator/denominator)-2.407948	    return AB_Vegadef get_distance_modulus(z):    """    A function to get distance modulus    """    if z <= 0.0:        return 0    elif cosmology_package_flag == 1:        return distance_modulus(z, **cosmo)    elif cosmology_package_flag == 2:        return cosmo.distmod(z).value# load SC/HSC filtersprint 'loading filter information...'try:    if camera_type == 0: # check camera_type variable if it represents Suprime-Cam        # Ufilter=np.loadtxt('/filter/SC/trans_U_qe_newMIT_prime_atm1.2_alumi_res')        Bfilter=np.loadtxt('./filter/SC/trans_B99_0deg_f1.86c_qe_newMIT_prime_atm1.2_alumi_res')        Vfilter=np.loadtxt('./filter/SC/trans_V_0deg_f1.86c_qe_newMIT_prime_atm1.2_alumi_res')        Rfilter=np.loadtxt('./filter/SC/trans_R_0deg_f1.86c_qe_newMIT_prime_atm1.2_alumi_res')        ifilter=np.loadtxt('./filter/SC/trans_iprime_0deg_f1.86c_qe_newMIT_prime_atm1.2_alumi_res')        zfilter=np.loadtxt('./filter/SC/trans_zprime_new_0deg_f1.86c_qe_newMIT_prime_atm1.2_alumi_res')        # convert responce function in frequency unit [E-15 Hz]        Bfilter_nu15, Bfilter_responce = convert_nu(Bfilter), convert_fnu(Bfilter)        Vfilter_nu15, Vfilter_responce = convert_nu(Vfilter), convert_fnu(Vfilter)        Rfilter_nu15, Rfilter_responce = convert_nu(Rfilter), convert_fnu(Rfilter)        ifilter_nu15, ifilter_responce = convert_nu(ifilter), convert_fnu(ifilter)        zfilter_nu15, zfilter_responce = convert_nu(zfilter), convert_fnu(zfilter)        filter_list = [Bfilter, Vfilter, Rfilter, ifilter, zfilter]        filter_initial = ['B','V','R','i','z']    elif camara_type == 1: # check camera_type variable if it represents Hyper Suprime-Cam        gfilter=np.loadtxt('./filter/HSC/g_hsc20120724ny.txt')        rfilter=np.loadtxt('./filter/HSC/r_hsc20120724ny.txt')        ifilter=np.loadtxt('./filter/HSC/i_hsc20120724ny.txt')        zfilter=np.loadtxt('./filter/HSC/z_hsc20120724ny.txt')        yfilter=np.loadtxt('./filter/HSC/y_hsc20120724ny.txt')        # convert responce function in frequency unit [E-15 Hz]        gfilter_nu15, gfilter_responce = convert_nu(gfilter), convert_fnu(gfilter)        rfilter_nu15, rfilter_responce = convert_nu(rfilter), convert_fnu(rfilter)        ifilter_nu15, ifilter_responce = convert_nu(ifilter), convert_fnu(ifilter)        zfilter_nu15, zfilter_responce = convert_nu(zfilter), convert_fnu(zfilter)        yfilter_nu15, yfilter_responce = convert_nu(yfilter), convert_fnu(yfilter)        filter_list = [gfilter, rfilter, ifilter, zfilter, yfilter]        filter_initial = ['g','r','i','z','y']    else:        print 'Please set correct parameter for camera_type. [0:SC 1: HSC]'    # load Johnson filter    JUfilter=np.loadtxt('./filter/Johnson/U3_res.txt')    JBfilter=np.loadtxt('./filter/Johnson/B2_res.txt')    JVfilter=np.loadtxt('./filter/Johnson/V_AS_res.txt')    JRfilter=np.loadtxt('./filter/Johnson/R_bessell_res.txt')    JIfilter=np.loadtxt('./filter/Johnson/I_bessell_res.txt')    # convert responce function in frequency unit [E-15 Hz]    JUfilter_nu15, JUfilter_responce = convert_nu(JUfilter), convert_fnu(JUfilter)    JBfilter_nu15, JBfilter_responce = convert_nu(JBfilter), convert_fnu(JBfilter)    JVfilter_nu15, JVfilter_responce = convert_nu(JVfilter), convert_fnu(JVfilter)    JRfilter_nu15, JRfilter_responce = convert_nu(JRfilter), convert_fnu(JRfilter)    JIfilter_nu15, JIfilter_responce = convert_nu(JIfilter), convert_fnu(JIfilter)    print 'successfully loaded filter information.'except Exception as e:    print e.message # print error message    print 'could not read filter files!'# set up Vega -> AB conversion fuctor# in the authour's calculation, the results were as below.# SC: B_Vega = -0.11588, V_Vega = 0.00074, R_Vega = 0.20673, i_Vega = 0.38385, z_Vega = 0.51540# HSC: g_Vega = -0.09748, r_Vega = 0.14191, i_Vega = 0.38575, z_Vega = 0.51682, y_Vega = 0.54576# Johnson: JU_Vega = 0.71210, JB_Vega = -0.11723, JV_Vega = 0.00529, JR_Vega = 0.19777, JI_Vega = 0.43974print 'calculating Vega -> AB conversion fuctor... (takes about several seconds)'if camera_type == 0: # SC case    B_Vega, V_Vega, R_Vega, i_Vega, z_Vega = \    [ AB_Vega_calc(each_filter) for each_filter in filter_list ]    for initial,AB_Vega in [['B',B_Vega],['V',V_Vega],['R',R_Vega],['i',i_Vega],['z',z_Vega]]:        print '%s %8.5lf' % (initial, AB_Vega)elif camera_type == 1: # HSC case    g_Vega, r_Vega, i_Vega, z_Vega, y_Vega = \    [ AB_Vega_calc(each_filter) for each_filter in filter_list ]    for initial,AB_Vega in [['g',g_Vega],['r',r_Vega],['i',i_Vega],['z',z_Vega],['y',y_Vega]]:        print '%s %8.5lf' % (initial, AB_Vega)JU_Vega, JB_Vega, JV_Vega, JR_Vega, JI_Vega = \[ AB_Vega_calc(each_filter) for each_filter in [JUfilter, JBfilter, JVfilter, JRfilter, JIfilter] ]for initial,AB_Vega in [['JU',JU_Vega],['JB',JB_Vega],['JV',JV_Vega],['JR',JR_Vega],['JI',JI_Vega]]:    print '%s %8.5lf' % (initial, AB_Vega)# load template parameters according to object_type.# 0:SN Ia (Hsiao) 1:SN Ia (Nugent) 2:SN Ia-91bg (Nugent) 3:SN Ia-91T (Nugent)# 4:SN Ibc (Nugent) 5:SN IIL (Nugent) 6:SN IIP (Nugent) 7:SN IIn (Nugent)print 'loading template parameters...'if object_type == 0: # SN Ia (Hsiao) case    targetdir = 'Hsiao_Ia' # template directory name    daylist = np.arange(-20,86,1) # the list of phase [day]    Mabs = absmag_norm + 0.0053571685 if absmag_type == 'B' else absmag_norm - 0.0356628458    # offset to make MB(Vega) or MV(Vega) in Johnson filter to absmag_norm mag    # For example, if you put absmag_type == 'B' and absmag_norm = -19.0,    # you'll have output LC normalized to M_B_abs = -19.0 at maximum    dayofmax = 0 # day of maximum in the corresponding fileelif object_type == 1: # SN Ia (Nugent) case    targetdir = 'Nugent_Ia'    daylist, dayofmax = np.arange(0,91,1), 20    Mabs = absmag_norm - 0.0180496024 if absmag_type == 'B' else absmag_norm - 0.0669946254elif object_type == 2: # SN Ia-91bg (Nugent)    targetdir = 'Nugent_Ia91bg'    daylist, dayofmax = np.arange(0,114,1), 13    Mabs = absmag_norm - 0.5053403604 if absmag_type == 'B' else absmag_norm - 0.0673492045elif object_type == 3: # SN Ia-91T (Nugent)    targetdir = 'Nugent_Ia91T'    daylist, dayofmax = np.arange(0,94,1), 23    Mabs = absmag_norm + 0.0307797561 if absmag_type == 'B' else absmag_norm - 0.0250060443elif object_type == 4: # SN Ibc (Nugent)    targetdir = 'Nugent_Ibc'    daylist, dayofmax = np.arange(0,86,1), 17    Mabs = absmag_norm - 0.4046198009 if absmag_type == 'B' else absmag_norm - 0.0394516436elif object_type == 5: # SN IIL (Nugent)    targetdir = 'Nugent_IIL'    daylist, dayofmax = np.array([0,1,6,11,16,21,36,61,86,111,136,411]), 11    Mabs = absmag_norm - 0.1979038678 if absmag_type == 'B' else absmag_norm - 0.0013434189elif object_type == 6: # SN IIP (Nugent)    targetdir = 'Nugent_IIP'    daylist, dayofmax = np.array([0,1,6,11,16,21,36,61,86,111,136,411]), 11    Mabs = absmag_norm - 0.1979038678 if absmag_type == 'B' else absmag_norm - 0.0013434189elif object_type == 7: # SN IIn (Nugent)    targetdir = 'Nugent_IIn'    daylist, dayofmax = np.array([0,1,2,3,4,6,9,14,20,31,46,59,81,97,128,137,227]), 14    Mabs = absmag_norm + 0.0205443175 if absmag_type == 'B' else absmag_norm - 0.0451377638# start calculating AB magnitude for each redshift, each phasesstart=time.time() # record start timecamera_name = 'SC' if camera_type == 0 else 'HSC'print 'calculating light curves using %s SED and %s filters' % (targetdir,camera_name)for z in np.arange(0.0,1.81,0.05):#for z in [0.0]:    # output file name (e.g. z055.dat for z=0.55)    fout=open('./%s/%s/z%03d.dat' % (camera_name,targetdir,z*100.1),'w')    print 'writing light curve to ./%s/%s/z%03d.dat ...' % (camera_name,targetdir,z*100.1)    if camera_type == 0: # write header for SC case        fout.write('#1 observer-frame phase [day]\n#2 Johnson U mag (Vega)\n#3 Johnson B mag (Vega)\n#4 Johnson V mag (Vega)\n#5 Johnson R mag (Vega)\n#6 Johnson I mag (Vega)\n\        #7 SC B mag (Vega)\n#8 SC V mag (Vega)\n#9 SC R mag (Vega)\n#10 SC i mag (Vega)\n#11 SC z mag (Vega)\n#12 Johnson U mag (AB)\n#13 Johnson B mag (AB)\n\        #14 Johnson V mag (AB)\n#15 Johnson R mag (AB)\n#16 Johnson I mag (AB)\n#17 SC B mag (AB)\n#18 SC V mag (AB)\n#19 SC R mag (AB)\n#20 SC i mag (AB)\n#21 SC z mag (AB)\n')    else:        fout.write('#1 observer-frame phase [day]\n#2 Johnson U mag (Vega)\n#3 Johnson B mag (Vega)\n#4 Johnson V mag (Vega)\n#5 Johnson R mag (Vega)\n#6 Johnson I mag (Vega)\n\        #7 HSC g mag (Vega)\n#8 HSC r mag (Vega)\n#9 HSC i mag (Vega)\n#10 HSC z mag (Vega)\n#11 HSC y mag (Vega)\n#12 Johnson U mag (AB)\n#13 Johnson B mag (AB)\n\        #14 Johnson V mag (AB)\n#15 Johnson R mag (AB)\n#16 Johnson I mag (AB)\n#17 HSC g mag (AB)\n#18 HSC r mag (AB)\n#19 HSC i mag (AB)\n#20 HSC z mag (AB)\n#21 HSC y mag (AB)\n')    # get distance modulus    DM = get_distance_modulus(z)    for epoch in daylist:    #for epoch in [dayofmax]:        # load SED        if targetdir=='Hsiao_Ia':            specdata = 'spectrum_m%02d.dat' % -epoch if epoch < 0 else 'spectrum_p%02d.dat' % epoch        else:            specdata='spectrum%02d.dat' % epoch        spectum_template = np.loadtxt('./SN_spectrum/'+targetdir+'/'+specdata)        model_lam = spectum_template[:,0]*1.0e-8 # [cm]        model_flam = spectum_template[:,1]        NBIN=len(model_lam)        # converting f_{lambda} to f_{nu}        model_fnu= np.array([0.0] * NBIN)        model_nu= np.array([0.0] * NBIN)        for i in range(NBIN):            model_fnu[i]=model_lam[NBIN-1-i]*model_lam[NBIN-1-i]*(model_flam[NBIN-1-i]*1.0e8)/c            model_nu[i]=c/model_lam[NBIN-1-i]        model_nu15=model_nu*1.0e-15        # integration        JUmag=abmagnitude(model_nu15,model_fnu,JUfilter_nu15,JUfilter_responce,z)+Mabs+DM        JBmag=abmagnitude(model_nu15,model_fnu,JBfilter_nu15,JBfilter_responce,z)+Mabs+DM        JVmag=abmagnitude(model_nu15,model_fnu,JVfilter_nu15,JVfilter_responce,z)+Mabs+DM        JRmag=abmagnitude(model_nu15,model_fnu,JRfilter_nu15,JRfilter_responce,z)+Mabs+DM        JImag=abmagnitude(model_nu15,model_fnu,JIfilter_nu15,JIfilter_responce,z)+Mabs+DM        if camera_type == 0: # SCam            Bmag=abmagnitude(model_nu15,model_fnu,Bfilter_nu15,Bfilter_responce,z)+Mabs+DM            Vmag=abmagnitude(model_nu15,model_fnu,Vfilter_nu15,Vfilter_responce,z)+Mabs+DM            Rmag=abmagnitude(model_nu15,model_fnu,Rfilter_nu15,Rfilter_responce,z)+Mabs+DM            imag=abmagnitude(model_nu15,model_fnu,ifilter_nu15,ifilter_responce,z)+Mabs+DM            zmag=abmagnitude(model_nu15,model_fnu,zfilter_nu15,zfilter_responce,z)+Mabs+DM            #if epoch - dayofmax ==0: print 'Johnson',JBmag-JB_Vega,JVmag-JV_Vega            #if epoch - dayofmax ==0: print 'SC',Bmag-B_Vega,Vmag-V_Vega            fout.write('%5.2f %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf\n' \            % ((epoch-dayofmax)*(1.+z),JUmag-JU_Vega,JBmag-JB_Vega,JVmag-JV_Vega,JRmag-JR_Vega,JImag-JI_Vega,Bmag-B_Vega,Vmag-V_Vega,Rmag-R_Vega,imag-i_Vega,zmag-z_Vega,JUmag,JBmag,JVmag,JRmag,JImag,Bmag,Vmag,Rmag,imag,zmag))            print '%4.2f %5.2f %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf' \            % (z,(epoch-dayofmax)*(1.+z),JUmag-JU_Vega,JBmag-JB_Vega,JVmag-JV_Vega,JRmag-JR_Vega,JImag-JI_Vega,Bmag-B_Vega,Vmag-V_Vega,Rmag-R_Vega,imag-i_Vega,zmag-z_Vega,JUmag,JBmag,JVmag,JRmag,JImag,Bmag,Vmag,Rmag,imag,zmag)        else: # HSC            gmag=abmagnitude(model_nu15,model_fnu,gfilter_nu15,gfilter_responce,z)+Mabs+DM            rmag=abmagnitude(model_nu15,model_fnu,rfilter_nu15,rfilter_responce,z)+Mabs+DM            imag=abmagnitude(model_nu15,model_fnu,ifilter_nu15,ifilter_responce,z)+Mabs+DM            zmag=abmagnitude(model_nu15,model_fnu,zfilter_nu15,zfilter_responce,z)+Mabs+DM            ymag=abmagnitude(model_nu15,model_fnu,yfilter_nu15,yfilter_responce,z)+Mabs+DM            fout.write('%5.2lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf\n' \            % ((epoch-dayofmax)*(1.+z),JUmag-JU_Vega,JBmag-JB_Vega,JVmag-JV_Vega,JRmag-JR_Vega,JImag-JI_Vega,gmag-g_Vega,rmag-r_Vega,imag-i_Vega,zmag-z_Vega,ymag-y_Vega,JUmag,JBmag,JVmag,JRmag,JImag,gmag,rmag,imag,zmag,ymag))            print '%4.2lf %5.2lf %6.3lf %lf %lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf %6.3lf' \            % (z,(epoch-dayofmax)*(1.+z),JUmag-JU_Vega,JBmag-JB_Vega,JVmag-JV_Vega,JRmag-JR_Vega,JImag-JI_Vega,gmag-g_Vega,rmag-r_Vega,imag-i_Vega,zmag-z_Vega,ymag-y_Vega,JUmag,JBmag,JVmag,JRmag,JImag,gmag,rmag,imag,zmag,ymag)    fout.close()end=time.time() # record end timecalculation_time = end - start# save logprint 'saving log...'fout=open('./%s/%s/log.txt' % (camera_name,targetdir),'w')fout.write('This file was created at %s\n\n' % time.ctime())# write instrument informationfout.write('### instrument information ###\ncamera: %s\nfilter: %s\n' % (camera_name,filter_initial))fout.write('Vega -> AB conversion factor:\n')if camera_type == 0:    for initial,AB_Vega in [['B',B_Vega],['V',V_Vega],['R',R_Vega],['i',i_Vega],['z',z_Vega]]:        fout.write(' %s %s %8.5lf\n' % (camera_name, initial, AB_Vega))else:    for initial,AB_Vega in [['g',g_Vega],['r',r_Vega],['i',i_Vega],['z',z_Vega],['y',y_Vega]]:        fout.write(' %s %s %8.5lf\n' % (camera_name, initial, AB_Vega))for initial,AB_Vega in [['U',JU_Vega],['B',JB_Vega],['V',JV_Vega],['R',JR_Vega],['I',JI_Vega]]:    fout.write(' Johnson %s %8.5lf\n' % (initial, AB_Vega))# write object informationfout.write('\n\n### object information ###\nobject type: SN %s\ntemplate author: %s\n' % (targetdir.split('_')[1],targetdir.split('_')[0]) )fout.write('normalization: absolute Vega magnitude to be M%s = %lf (Johnson filter) at maximum light\n' % (absmag_type, absmag_norm))fout.write('\n\nTotal calculation time was %lf seconds\n' % calculation_time)print 'That\'s all folks'